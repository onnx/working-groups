**Dumitru's proposal concerning broadcasting**

ONNX has pretty complex broadcasting rules, described 
here: 
  https://onnx.ai/onnx/repo-docs/Broadcasting.html
They claim they follow Numpy's rules on most operators,
as defined here:

  https://numpy.org/doc/stable/user/basics.broadcasting.html#general-broadcasting-rules

and a different rule on Gemm and on Prelu.

But both rules are pretty complex. 

> (Eric) They are not *** that *** complex but, for sure, adding broadcasting will make our life more complicated.
>> (Dumitru) It's arguably more complex than the operators that use it, like "add".

Thus, it draws attention away from the core functionality of the operator to the broadcasting.

The question is: how to define the *semantics* of operators that perform broadcast? Add the (explicit) description of broadcasting to all operators performing it, or defined the  operator semantics separately, and the broadcast separately?

One first remark here is that actually decomposing inside ONNX for implementation purposes does not seem to be possible, as no explicit broadcast operator exists. This is unlike in numpy,  where functions exist both for the broadcast of a tensor to a shape:

  https://numpy.org/doc/stable/reference/generated/numpy.broadcast_to.html#numpy.broadcast_to

and for computing the broadcast shape.

  https://numpy.org/doc/stable/reference/generated/numpy.broadcast_shapes.html#numpy.broadcast_shapes

However, for semantics definition purposes, my suggestion would be to decompose by introducing a "virtual" broadcast operator (e.g. why3 functions corresponding to numpy.broadcast_to, numpy.broadcast_shapes) and then defining the full semantics of the operator by composing this with a simple definition of the base operator.

> (eric) As you write above, the other solution is to specify the operation including the broadcasting, as it will >be actually done in the implementation. This will  make the mathematical formulation and the formal spec  significantly more complicated because we will have to play with mods whenever we compute an index.

>> (Dumitru) Exactly.

Something like:
```  
x = onnx.add(y,z)
```
would become:
```
  x_shape = broadcast_shapes(shape(y),shape(z))
  y_full = broadcast_to(y,x_shape)
  z_full = broadcast_to(z,x_shape)
  x = add_homogenous(y_full,z_full)
```

> (Eric) I fully agree with the approach. 
> We may possibly add a predicate "need broadcasting" so that we can clearly express in which condition broadcasting is nedeed and possible. This will anyway be necessary to express the usage constraints.   
So, I propose that we keep the capability of broadcasting  (for the moment we can keep our spec as is and we will add broadcasting in a second phase).

> (Eric) Note that concerning  `x_shape = broadcast_shapes(shape(y),shape(z))`, this raises another question : we have also forbidden shape inference. Normally, the shape of x should be known in advance...

>> (Dumitru) Oh, then it's even easier, requiring in the operation properties that the constant x_shape provided by the programmer satisfies "x_shape = broadcast_shapes(shape(y),shape(z))" 
