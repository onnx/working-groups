*Please provide your comments, questions, proposals here. They will be discussed during the Feb 18th 2026 workshop.*


### Formalization of floating point operators
- What do really want to express / need?
- How shall we specify operations in F (floating point numbers)?    
    - For simple operations such as Add() or Mul(), we could specify the operation wrt their counter parts in R, e.g. something like: if $x$ and $y$ are FP tensors, and $+$ and $+.$ are the addition operators for floats and real, respectively:
    $$
        round(x+y)=round(round(x) + round(y))
    $$ 
    - Shall we adopt this "strategy" for simple operations (extending it to inf and Nan, non representable numbers)? even if it can't be appied to other operations... 
- Ideally : the formalization of floating point number and their operations should include the effect of rounding and the special values 
- Nota: In Why3, there are axiomatic models of IEEE754 numbers (see [Formalization of Floating-Point Arithmetic](https://www.why3.org/stdlib/ieee_float.html)).
    The module provides constructors, some operations (add, sub, etc.). 
    It also provides some axioms that define the expected behaviour of FP numbers, by relating the result to the operation in R e.g.,
    ```
      axiom add_finite: forall m:mode, x y:t [add m x y].
    is_finite x -> is_finite y -> no_overflow m (to_real x +. to_real y) ->
    is_finite (add m x y) /\
    to_real (add m x y) = round m (to_real x +. to_real y)
    ``` 
- Bottom line: model floating point operations as operations in R extended with Infs and NaN.  

### Modeling of booleans
- Currely, booelans are modeled using floating point numbers (the value is "True" if it is greater than 0). 
- WOuld it be possible / make sense to use "built-in" booleans (in the "high-level" spec) and integers (in the "low-level" spec), with a mapping between them (`function b_to_i(nb: bool) : int = if b then 1 else 0`). 

### Generic tensors and type-specific tensors



