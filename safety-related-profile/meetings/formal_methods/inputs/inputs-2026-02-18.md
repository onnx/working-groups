*Please provide your comments, questions, proposals here. They will be discussed during the Feb 18th 2026 workshop.*
### Dynamic allocation
Is it possible to avoid dynamic allocation in operator implementations with minimal modifications to the existing code? For example, the conv2d operator currently allocates memory dynamically for x_coords, w_coords, b_coords, and output_coords. 
### Code generation
When we try to generate code for the `Where` operator, the C file is empty...
For more details: If we separate the general specification (ctensor) from the operator specification (abstract + concrete specification), generating C code produces the ctensor implementation (ctensor.c), but not the operator implementation (where.c).

### Formalization of floating point operators
- What do really want to express / need?
- How shall we specify operations in F (floating point numbers)?    
    - For simple operations such as Add() or Mul(), we could specify the operation wrt their counter parts in R, e.g. something like: if $x$ and $y$ are FP tensors, and $+$ and $+.$ are the addition operators for floats and real, respectively:
    $$
        round(x+y)=round(round(x) + round(y))
    $$ 
    - Shall we adopt this "strategy" for simple operations (extending it to inf and Nan, non representable numbers)? even if it can't be appied to other operations... 
- Ideally : the formalization of floating point number and their operations should include the effect of rounding and the special values 
- Nota: In Why3, there are axiomatic models of IEEE754 numbers (see [Formalization of Floating-Point Arithmetic](https://www.why3.org/stdlib/ieee_float.html)).
    The module provides constructors, some operations (add, sub, etc.). 
    It also provides some axioms that define the expected behaviour of FP numbers, by relating the result to the operation in R e.g.,
    ```
      axiom add_finite: forall m:mode, x y:t [add m x y].
    is_finite x -> is_finite y -> no_overflow m (to_real x +. to_real y) ->
    is_finite (add m x y) /\
    to_real (add m x y) = round m (to_real x +. to_real y)
    ``` 
- Bottom line: model floating point operations as operations in R extended with Infs and NaN.  

### Modeling of booleans
- Currely, booelans are modeled using floating point numbers (the value is "True" if it is greater than 0). 
- WOuld it be possible / make sense to use "built-in" booleans (in the "high-level" spec) and integers (in the "low-level" spec), with a mapping between them (`function b_to_i(nb: bool) : int = if b then 1 else 0`). 

---

### Two levels of formalization
- (João and Ricardo)
    - Is there any motivation/reason for having two levels of formalization (abstract and concrete)?

    - We assume that one of the reasons behind this choice was to have a link between the naturally structural representation of tensors, used by ONNX and multiple other frameworks, and the target representation proposed by SONNX (a flattened array). Is there any other motivation for adopting such formalisation strategy?

        - As far as we have explored, in the abstract spec, the formalization seems to be carried out using a more functional style; on the other hand, in the concrete formalization a more imperative style is adopted.´

            - Is this what is intended?

            - If so, do the proofs become more complicated when different styles are used?
---
### Empty tensors
- (João and Ricardo)
    - We believe that, at this moment, in the abstract formalization, it is not possible to represent **empty tensors** - tensors with at least one of their dimensions equal to **zero**. What leads us to believe this is the following invariant.

    ``` 
    invariant { positive dims }
    ```
    - Is there any reason why empty tensors are not allowed in the abstract formalization?

    \
    We have noticed that, in the concrete formalization, several functions make use of the predicate `valid_tensor`, present in the file `libtensor.mlw`, or of the predicate `dimension`, present in the file `libvector.mlw`.

    ```
    predicate valid_tensor (t : ctensor) =
        dimension t.t_dims t.t_rank /\
        valid_range t.t_data 0 (tensor_size t) /\
        writable t.t_data
    ```
    ```
    predicate dimension (u : iarray) (n : int) =
        0 <= n /\ valid_range u 0 n /\ pdim u 0 n /\ 0 < vdim u n <= max_int32
    ```
   The predicate `dimension` in turn uses the predicate `pdim`, which is defined as:

    ```    
    predicate pdim (u : iarray) (p q : int) =
        forall k. p <= k < q -> 0 < value_at u k
    ```

    - Despite the absence of direct invariants over the ctensor type and the fact that we can create empty tensors at this level of the formalisations, they would not hold the predicate `valid_tensor`. After discussing this in the WG it became quite clear that empty tensors are indeed to be allowed. If so, what would be the consequences of this both at the abstract and concrete level?

**Suggestion**
- From our point of view these are the changes that would need to be done at each one of the levels:

    - **Abstract level**:
        - Instead of a **positive** predicate we would have to define a **non-negative**

        - All the **let rec lemmas** previously defined for **positive** invariant would need to be adjusted to support the **non-negative** invariant
     
    - **Concrete level**:
        - Creation of an **ndim** predicate that is equal to **pdim** but instead of saying **positive**, says **non-negative**

        - Creation of an **ndimension** predicate which copies the semantics of **dimension**, calling **ndim** instead of **pdim**
        - Adjust all **let rec lemmas** that already exist for predicate **pdim** to be in conformity with the predicate **ndim**
        - **cdim_size** should now accept a list of dimensions with 0s and therefore the **let ghost construct** _**mult_bound**_ does not hold in this context. There seems to be two possible ways of solving such issue:
            - Change **let ghost construct** _**mult_bound**_ definition to hold for lists with non negative values (including zero). We have already tried this one, however, we were not successful.
            
            - Having a **null_dimensions_check** that checks wether any dimension in the specified list is 0. **cdim_size** would now have an if statement based on the result of **null_dimensions_check**.
        - **Valid_tensor** predicate will then be changed to use **ndimension** predicate instead of **dimension**.

- [Empty tensors suggestion](./empty_tensors)
---
### Function Contracts
- (João and Ricardo)

    - In the abstract world, the definition and specification of functions enter as logical context as they are all ghost functions. It seems to us important to have contracts as they are the assurance that based on some well-defined pre-conditions some post-conditions will be verified for all possible inputs. Based on that we are struggling to understand what are the role of these contracts in the abstract level.

        - Should they exist and specify properties of the functions?

        - Should they not be present at this level?
        
        - Should they be part only at specific functions in this level?

    - Furthermore, and related to this, we would like to have your input in one of the structural operators we have worked on - flatten. The flatten's informal and formal specifications are, respectively, in the following links: [flatten informal specification](../../../sonnx/ops/spec/informal/flatten/flatten.md), [flatten formalization](../../../sonnx/ops/spec/formal/flatten/flatten.mlw).
        
        - What is your opinion with regard to the abstract level contracts? (Are they enough? Should they be discarded? This question is not specific to the flatten function, but also to every auxiliar function in the file.)
        
        - For this operator the concrete level formalisation will only make a copy of two different arrays.
            
            - In such case how strong and meaningful should our invariant be in order to prove the link (post-condition/assert) between both levels?

            - Do have any suggestions so that we can successfully prove the relation between both levels for this operator?

    - For some operators wich we have already worked on, the Cformalisation implementation uses the **malloc** function. In such cases, for acessing the data we have to check if the pointer is not null. To do so we are currently using an if-statement. An operator in wich our formalisation strategy uses **malloc** is the [matmul formalization](../../../sonnx/ops/spec/formal/matmul/matmul.mlw). Regarding this strategy we fall in the same problem stated above: how can we sucessfully prove the relation between both levels for this operator, particularly in the case where **malloc** returns a null pointer.

---
### Generic tensors and type-specific tensors
- (João and Ricardo)
    - The strategy of formalisation used so far is not generic with respect to the **datatype of the ctensors**. In order to turn this strategy type-generic we have explored two different alternatives:

    - **Clone-based approach**

        - In this strategy we **declare** three types: a **concrete datatype**, an **abstract datatype** and a **function** that maps a concrete datatype to the respective abstract datatype.

        - The already existing functions in the **ctensor module** were adapted to use the appropriate types and the respective mapping function.

        - To create a specific tensor datatype we need only to clone the module instantiating the **concrete datatype**, the **abstract datatype** and the **function** that maps a concrete datatype to the respective abstract datatype.

        - We were able to **generate C-code**, and **prove the cWhere operator** while using such strategy.

    - **CTensor parametrized datatype**

        - Similar to what was used for the abstract tensors formalisation, using an **a'** and a **b'** datatype to capture the concrete, abstract levels, respectively. Every function that needs to map the concrete onto the abstract would need to receive as an **argument** the **mapping function** that goes from **a'** to **b'**.

        - With this strategy we were not able to extract C-code.

    - What is your opinion regarding these two approaches? Is one of them more suited than the other, or is there any other approach that would be more adequate?

- [Generic tensors suggestion](./generic_tensors)
