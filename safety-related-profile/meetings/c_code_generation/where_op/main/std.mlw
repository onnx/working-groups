(* Extensions to Standard Library *)

module Int
  use export int.Int
  use export int.Abs
  use export int.ComputerDivision

  (** Unicity of euclidian division decomposition *)
  let ghost euclide (a b q r : int)
    requires { 0 <= a /\ 0 <= r < q }
    requires { a = b * q + r }
    ensures { b = div a q }
    ensures { r = mod a q }
    (*proof*)
    = let rec kernel (b r : int)
        requires { b * q + r = 0 }
        requires { abs r < q }
        ensures { b = r = 0 }
        variant { abs b }
        = if b < 0 then kernel (b + 1) (r - q) else
          if b > 0 then kernel (b - 1) (r + q) else ()
      in kernel (b - div a q) (r - mod a q)
    (*qed*)

  (** Multiplication upper-bound *)
  let ghost mult_bound (a b c : int)
    requires { 0 < a * b <= c }
    ensures { abs a <= c }
    ensures { abs b <= c }
    = ()

end

module List
  use export list.List
  use export list.Map
  use export list.Append

  (** Appends an element to the end of the list *)
  function push (xs : list 'a) (x : 'a) : list 'a =
    xs ++ Cons x Nil

  let rec lemma map_concat (f : 'a -> 'b) (xs ys : list 'a)
    ensures { map f (xs ++ ys) = map f xs ++ map f ys }
    (*proof*)
    variant { xs }
    = match xs with Cons _ rxs -> map_concat f rxs ys | Nil -> () end
    (*qed*)

end

module Clib
  use map.Map
  use int.Int
  use mach.int.Int32
  use export mach.c.C

  type int32 = Int32.int32

  (** Array-range validity *)
  predicate valid_range (vp : ptr 'a) (p q : int) =
    q <= p \/
    ( 0 <= vp.min <= vp.offset /\
      0 <= p <= q <= max_int32 /\
      0 <= vp.min <= vp.offset /\
      vp.offset + q <= vp.max <= vp.plength )

  let lemma valid_in_range (vp : ptr 'a) (p k q : int)
    (*proof*)
    requires { p <= k < q }
    requires { valid_range vp p q }
    ensures { valid_ptr_shift vp k }
    = ()
    (*qed*)

  (** Array as map *)
  let ghost function value_at (vp : ptr 'a) : map int 'a =
    pure { fun k -> vp.data.Array.elts (vp.offset + k) }

  (** Array access (ghost) *)
  function ([]) (vp : ptr 'a) (k : int) : 'a = value_at vp k

  (** Array access (C, inlined) *)
  let ([]) (vp : ptr 'a) (k : int32) : 'a
    (*proof*)
    requires { vp.min <= vp.offset + k < vp.max }
    ensures { result = vp[k] }
    = get_ofs vp k
    (*qed*)

  (** Array update (C, inlined) *)
  let ([]<-) (vp : ptr 'a) (k : int32) (v : 'a) : unit
    requires { writable vp }
    requires { vp.min <= vp.offset + k < vp.max }
    ensures { value_at vp = Map.([<-]) (old (value_at vp)) k v }
    = set_ofs vp k v

  (** Array as list *)
  use List

  let rec ghost function slice (u : ptr 'a) (p q : int) : list 'a =
    (*proof*)
    variant { q - p }
    (*qed*)
    if q <= p then Nil else Cons (value_at u p) (slice u (p+1) q)

  let rec lemma slice_append (u : ptr 'a) (p q r : int)
    requires { p <= q <= r }
    ensures { slice u p r = slice u p q ++ slice u q r }
    (*proof*)
    variant { q - p }
    = if p < q then slice_append u (p+1) q r
    (*qed*)

  let ghost function vector (u : ptr 'a) (n : int) = slice u 0 n

  let lemma vector_push (u : ptr 'a) (n : int)
    requires { 0 <= n }
    ensures { vector u (n+1) = push (vector u n) (value_at u n) }
    (*proof*)
    = slice_append u 0 n (n+1)
    (*qed*)

end
