
(** Offset & Dimensions *)
module CIndex
  use std.Int
  use std.List
  use std.Clib
  use mach.int.Int32
  use tensor.Range
  use layout.CFlat

  type iarray = ptr int32

  function ivector (u : iarray) (n : int) : list int
    = map Int32.to_int (vector u n)

  function islice (u : iarray) (p q : int) : list int
    = map Int32.to_int (slice u p q)

  (** ## Dimensions *)

  function vdim (u : iarray) (n : int) : int = size (ivector u n)
  function sdim (u : iarray) (p q : int) : int = size (islice u p q)

  predicate pdim (u : iarray) (p q : int) =
    forall k. p <= k < q -> 0 < value_at u k

  predicate dimension (u : iarray) (n : int) =
    0 <= n /\ valid_range u 0 n /\ pdim u 0 n /\ vdim u n <= max_int32

  (** Equivalence betwen {pdim} and {tensor.Range.positive}. *)
  let rec lemma positive_pdim (u : iarray) (p q : int)
  (*proof*)
    ensures { pdim u p q <-> positive (islice u p q) }
    variant { q - p }
    = if p < q then positive_pdim u (p+1) q
  (*qed*)

  let ghost sdim_split (u : iarray) (p k q : int)
  (*proof*)
    requires { p <= k < q }
    requires { pdim u p q }
    ensures { sdim u p k * value_at u k * sdim u (k+1) q = sdim u p q }
    = assert { islice u p k ++ islice u k q = islice u p q }
  (*qed*)

  (** Extracted Library *)

  let cdim_size (u : iarray) (n : int32): int32 =
    ensures { result = vdim u n }
    (*proof*)
    requires { dimension u n }
    (*qed*)
    begin
      let ref p = 1 in
      for i = 0 to n - 1 do
        (*proof*)
        invariant { p = vdim u i }
        ghost
          begin
            ensures { 1 <= p * u[i] <= max_int32 }
            let ghost dl = pure { sdim u 0 i } in
            let ghost di = Int32.to_int u[i] in
            let ghost dr = pure { sdim u (i+1) n } in
            let ghost dn = pure { sdim u 0 n } in
            sdim_split u 0 (Int32.to_int i) (Int32.to_int n) ;
            mult_bound (dl * di) dr dn ;
          end ;
        (*qed*)
        p <- p * u[i] ;
      done ; p
    end

  let cdim_create_1 (n : int32) : iarray =
    requires { 0 < n }
    ensures { is_not_null result -> vdim result 1 = n }
    (*proof*)
    ensures { is_not_null result -> dimension result 1 }
    ensures { is_not_null result -> value_at result 0 = n }
    (*qed*)
    let cd = malloc 1 in
    if is_not_null cd then cd[0] <- n ; cd

  let cdim_create_2 (p q : int32) : iarray =
    requires { 0 < p /\ 0 < q /\ p * q <= max_int32 }
    ensures { is_not_null result -> vdim result 2 = p * q }
    (*proof*)
    ensures { is_not_null result -> dimension result 2 }
    ensures { is_not_null result -> value_at result 0 = p }
    ensures { is_not_null result -> value_at result 1 = q }
    (*qed*)
    let cd = malloc 2 in
    if is_not_null cd then (cd[0] <- p ; cd[1] <- q) ; cd

  (** ## Coordinates *)

  let coffset (ks : iarray) (ds : iarray) (n : int32) : int32 =
    (*proof*)
    requires { 0 <= n }
    requires { valid_range ks 0 n }
    requires { valid_range ds 0 n }
    requires { vdim ds n < max_int32 }
    ensures { 0 <= result -> dimension ds n }
    ensures { 0 <= result -> valid (ivector ks n) (ivector ds n) }
    ensures { 0 <= result -> result = offset (ivector ks n) (ivector ds n) }
    (*qed*)
    begin
      assume { false } ;
      let ref p = 0 in
      for i = 0 to n - 1 do
        let d = ds[i] in
        let k = ks[i] in
        if 0 <= k && k < d then
          p <- p * d + k
        else return (-1)
      done ; p
    end

end
