module Range
  use int.Int
  use std.List

  function size (ds : list int) : int =
    match ds with
    | Nil -> 1
    | Cons d ds -> d * size ds
    end

  predicate positive (ds : list int) =
    match ds with
    | Nil -> true
    | Cons d ds -> 0 < d /\ positive ds
    end

  predicate valid (ks ds : list int) =
    match ks , ds with
    | Nil , Nil -> true
    | Cons k ks , Cons d ds -> 0 <= k < d /\ valid ks ds
    | _ -> false
    end

  let rec lemma size_append (xs ys : list int)
    ensures { size (xs ++ ys) = size xs * size ys }
    (*proof*)
    variant { xs }
    = match xs with Cons _ rxs -> size_append rxs ys | Nil -> () end
    (*qed*)

  lemma size_push: forall xs x. size (push xs x) = size xs * x

  let rec lemma positive_size (ds : list int)
    requires { positive ds }
    ensures { 0 < size ds }
    (*proof*)
    variant { ds }
    = match ds with Nil -> () | Cons _ ds -> positive_size ds end
    (*qed*)

  let rec lemma positive_valid (ks ds : list int)
    requires { valid ks ds }
    ensures { positive ds }
    ensures { 0 < size ds }
    (*proof*)
    variant { ds }
    = match ks , ds with
      | Cons _ ks , Cons _ ds -> positive_valid ks ds
      | _ -> ()
      end
    (*qed*)

end

module Tensor
  use int.Int
  use map.Map
  use list.List
  use Range

  type data 'a = map (list int) 'a

  type tensor 'a = {
    dims : list int ;
    data : data 'a ;
  } invariant { positive dims }
  meta coercion function data

  (** Tensor with the same dimensions *)
  predicate (~) (a : tensor 'a) (b : tensor 'b) = a.dims = b.dims

end

module OPWhere
  use Tensor

  let function dwhere (c : data bool) (a b : data 'a) : data 'a
    = fun ks -> if c ks then a ks else b ks

  let opwhere (c : tensor bool) (a b : tensor 'a) : tensor 'a
    requires { c ~ a ~ b }
    ensures { result ~ c ~ a ~ b }
    ensures { result = dwhere c a b }
    (*proof*)
    = { dims = c.dims ; data = dwhere c.data a.data b.data }
    (*qed*)

end
