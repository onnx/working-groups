(** OP-LeakyReLU Tensor Operation *)
module OPLeakyReLU
  use real.Real
  use tensor.tensor.Tensor
  use tensor.tensor.Range

  let ghost constant alpha : real = 1.0  (* J'arrive pas a faire une multiplication avec OPLeakyReLU.alpha *)


  let ghost function leakyrelu (x : real) : real =
    if x < Real.(0.0) then
      alpha * x
    else
      x

  let ghost function dleakyrelu (x : tensor real) : data real
    = fun ks ->
      if valid ks x.dims then
        leakyrelu (x.data ks)
      else
        x.background

  let ghost function opleakyrelu (x : tensor real) : tensor real
    ensures { result.dims = x.dims }
    ensures { result.background = x.background }
    ensures { result.data = dleakyrelu x }
    (*proof*)
    = { dims = x.dims ; data = dleakyrelu x ; background = x.background }
    (*qed*)

end
module CTensorLeakyReLU
  use tensor.std.Int
  use tensor.std.List
  use tensor.std.Clib
  use tensor.std.Cfloat
  use mach.int.Int32
  use tensor.tensor.Range
  use tensor.tensor.Tensor
  use OPLeakyReLU
  use tensor.layout.CFlat
  use tensor.libvector.CIndex
  use tensor.libtensor.CTensor

  constant alpha_f : f32  = 1.0

let ctensor_leakyrelu (x r : ctensor) =
  (*proof*)
  requires { valid_tensor x }
  requires { valid_tensor r }
  requires { tensor x ~= tensor r }
  (*qed*)
  ensures { tensor r = opleakyrelu (tensor x) }

  let m = cdim_size r.t_dims r.t_rank in
  for i = 0 to m - 1 do
    (*proof*)
    invariant {
      forall k. 0 <= k < i ->
        value_at r.t_data k =
          if Real.(value_at x.t_data k < 0.0) then
            value_at x.t_data k (* J'arrive pas a faire une multiplication avec alpha *)
          else
            value_at x.t_data k
    }
    (*qed*)

    r.t_data[i] <-
      if Real.(x.t_data[i] .< (f32 0.0)) then
        x.t_data[i] (* J'arrive pas a faire une multiplication avec OPLeakyReLU.alpha *)
      else
        x.t_data[i]
  done

  (*proof*)
  ; assert { tensor r == opleakyrelu (tensor x) }
  (*qed*)
end
