(** Formalization of coordinates and dimensions *)

module Range
  use int.Int
  use tensor.std.List

  function size (ds : list int) : int =
    match ds with
    | Nil -> 1
    | Cons d ds -> d * size ds
    end

  predicate positive (ds : list int) =
    match ds with
    | Nil -> true
    | Cons d ds -> 0 < d /\ positive ds
    end

  predicate valid (ks ds : list int) =
    match ks , ds with
    | Nil , Nil -> true
    | Cons k ks , Cons d ds -> 0 <= k < d /\ valid ks ds
    | _ -> false
    end

  let rec lemma valid_push (ks ds : list int) (k d : int)
    requires { 0 <= k < d }
    requires { valid ks ds }
    ensures { valid (push ks k) (push ds d) }
    (*proof*)
    variant { ks }
    = match ks , ds with
      | Nil , Nil -> ()
      | Cons _ ks , Cons _ ds -> valid_push ks ds k d
      | _ -> absurd
      end
    (*qed*)

  let rec lemma size_append (xs ys : list int)
    ensures { size (xs ++ ys) = size xs * size ys }
    (*proof*)
    variant { xs }
    = match xs with Cons _ rxs -> size_append rxs ys | Nil -> () end
    (*qed*)

  lemma size_push: forall xs x. size (push xs x) = size xs * x

  let rec lemma positive_size (ds : list int)
    requires { positive ds }
    ensures { 0 < size ds }
    (*proof*)
    variant { ds }
    = match ds with Nil -> () | Cons _ ds -> positive_size ds end
    (*qed*)

  let rec lemma positive_valid (ks ds : list int)
    requires { valid ks ds }
    ensures { positive ds }
    ensures { 0 < size ds }
    (*proof*)
    variant { ds }
    = match ks , ds with
      | Cons _ ks , Cons _ ds -> positive_valid ks ds
      | _ -> ()
      end
    (*qed*)

end

(** Formalization of Tensor *)
module Tensor
  use int.Int
  use map.Map
  use list.List
  use Range

  type data 'a = map (list int) 'a

  type tensor 'a = {
    dims : list int ;
    data : data 'a ;
    background : 'a ; (* default value, or value for 0-dimensions tensor *)
  }
  invariant { positive dims }
  invariant { forall k. valid k dims \/ data k = background }
  (*proof*)
  by let d = any 'a in { dims = Nil ; data = (fun _ -> d) ; background = d }
  (*qed*)

  meta coercion function dims
  meta coercion function data

  (** Tensor with the same dimensions *)
  predicate (~) (a : tensor 'a) (b : tensor 'b) = a.dims = b.dims

  (** Tensor with the same dimensions and background value *)
  predicate (~=) (a : tensor 'a) (b : tensor 'a) =
    a ~ b /\ a.background = b.background

  (** Equal tensors *)
  predicate (==) (a b : tensor 'a) =
    a ~= b /\ forall k. valid k a.dims -> a.data k = b.data k

  (** Extensionality *)
  lemma exteq: forall a b : tensor 'a. a == b <-> a = b
  (*proof*) by tensor'eq a b (*qed*)

  (** Scalar Tensor *)
  let ghost function scalar (v : 'a) : tensor 'a
    ensures { result.dims = Nil }
    ensures { result.background = v }
    ensures { forall k. result k = v }
    (*proof*)
    = { dims = Nil ; data = (fun _ -> v) ; background = v }
    (*qed*)

  (** Null Tensor *)
  let ghost function zero (e : 'a) (ds : list int) : tensor 'a
    requires { positive ds }
    ensures { result.dims = ds }
    ensures { result.background = e }
    ensures { forall k. result k = e }
    (*proof*)
    = { dims = ds ; data = (fun _ -> e) ; background = e }
    (*qed*)


  (** Constant Tensor *)
  let ghost function const (v : 'a) (bg : 'a) (ds : list int): tensor 'a
    ensures { result.dims = ds }
    requires { positive ds }
    ensures { result.background = bg }
    ensures { forall k. valid k ds -> result k = v }
    (*proof*)
    = { dims = ds ; data = pure { fun k -> if valid k ds then v else bg } ; background = bg }
    (*qed*)

  (** Constant & Null *)
  goal zero_is_const: forall e : 'a, ds. positive ds -> zero e ds == const e e ds

end
