module CFlat
  use tensor.std.Int
  use tensor.std.List
  use tensor.tensor.Range

  function offset (ks ds : list int) : int =
    match ks , ds with
    | Cons k ks , Cons _ ds -> k * size ds + offset ks ds
    | _ -> 0
    end

  function index (p : int) (ds : list int) : list int =
    match ds with
    | Nil -> Nil
    | Cons _ ds -> let n = size ds in Cons (div p n) (index (mod p n) ds)
    end

  let rec lemma offset_size (ks ds : list int)
    requires { valid ks ds }
    ensures { 0 <= offset ks ds < size ds }
    (*proof*)
    variant { ds }
    = match ks , ds with
      | Cons k krs , Cons d drs ->
        offset_size krs drs ;
        let p = offset ks ds in
        let q = offset krs drs in
        assert { p = size drs * k + q } ;
        assert {
             size drs * k
          <= size drs * (d - 1)
           = d * size drs - size drs
        } ;
      | _ -> ()
      end
    (*qed*)

  let rec lemma index_range (p : int) (ds : list int)
    requires { positive ds }
    requires { 0 <= p < size ds }
    ensures { valid (index p ds) ds }
    (*proof*)
    variant { ds }
    = match ds with
      | Nil -> ()
      | Cons _ rds -> index_range (mod p (size rds)) rds
      end
    (*qed*)

  let rec lemma index_of_offset (ks ds : list int)
    requires { valid ks ds }
    ensures { index (offset ks ds) ds = ks }
    (*proof*)
    variant { ds }
    = match ks , ds with
      | Cons k rks , Cons _ rds ->
          index_of_offset rks rds ;
          let p = offset ks ds in
          let n = size rds in
          let q = offset rks rds in
          euclide p k n q ;
      | _ -> ()
      end
    (*qed*)

  let rec lemma offset_of_index (p : int) (ds : list int)
    requires { positive ds }
    requires { 0 <= p < size ds }
    ensures { offset (index p ds) ds = p }
    (*proof*)
    variant { ds }
    = match ds with
      | Nil -> ()
      | Cons _ rds ->
        let n = size rds in
        offset_of_index (mod p n) rds
      end
    (*qed*)

  let rec lemma offset_push (ks ds : list int) (k d : int)
    requires { valid ks ds }
    ensures { offset (push ks k) (push ds d) = offset ks ds * d + k }
    (*proof*)
    variant { ks }
    = match ks , ds with
      | Cons _ krs , Cons _ drs -> offset_push krs drs k d
      | _ -> ()
      end
    (*qed*)

end
