# Contents

- **Clip** operator for type [real](#real)
- **Clip** operator for types [INT8, INT16, INT32, INT64, UINT8, UINT16, UINT32, UINT64](#int)
- **Clip** operator for types [FP16, FP32, FP64, BFLOAT16](#floats)

> Use lowercases for all types, throughout the document.
> For FP numbers, use the ONNX standard types: float16, float, double... 
> Remove BFLOAT16 (not supported by IEEE)

Based on ONNX documentation version 13.

<a id="real"></a>
# **Clip** (real)

## Signature
$Y = \text{Clip}(X,L,M)$

where:
- $X$: input tensor
- $L$: minimum tensor (empty shape tensor - scalar)
- $M$: maximum tensor (empty shape tensor - scalar)

> Use the same names as ONNX, i.e., "input", "min", "max", "output".
> remove "empty shape tensor" and simply use "scalar". 
> In order to keep mathematical formulae simple, introduce a simpler denotation (if needed).
> For instance:
>- $input$: input tensor (denoted by $X$)
>- $min$: minimum value (scalar) (denoted by $L$)
>- $max$: maximum value (scalar) (denoted by $M$)

## Restrictions
The following restrictions apply to the $\text{Clip}$ operator for the SONNX profile:

[General restrictions](../general_restrictions.md) are applicable.

## Informal specification

> As stated before, at interface level we must use ONX names ("min", "max",...). But for the formulae, we should probably stick to mathematical symbols.

Operator $\text{Clip}$ limit the given input within an interval. For each element in the input tensor $X$: 
- If $L$ $\leq$ $M$:
  - if $X[i] < L$ then $Y[i]$ = $L$.
  - If $X[i] > M$ then $Y[i]$ = $M$.
  - Otherwise, $Y[i] = X[i]$.
- If $L$ $\gt$ $M$:
  - $Y[i] = M$

> /!\ See the new formatting (pb with ">" and "<"). Do as shown above.
> Remove "forall i" (because "i" is used before)

where $i$ is a [tensor index](../common/definitions.md#tensor_index).

The result is stored in output tensor $Y$.

> The use of "stored" is strange since (conceptually) a tensor is a mathematical object (not a variable). 
> And the specification defines $Y$, so this sentence could well be removed (everywhere). 

Clip operation can ALSO be expressed as:

$$\forall i,\ Y[i] = \min(M, \max(X[i], L))$$

where $i$ is a [tensor index](../common/definitions.md#tensor_index).

### Example 1

```math
A = \begin{bmatrix} -6.1 & 9.5 & 35.7 \end{bmatrix}
```

> "A" is "X"

```math
L = 0
\quad
M = 10
```

```math
Y = \begin{bmatrix} \min(10, \max(-6.1, 0)) & \min(10, \max(9.5, 0)) & \min(10, \max(35.7, 0)) \end{bmatrix}
```

```math
Y = \begin{bmatrix} 0 & 9.5 & 10 \end{bmatrix}
```

### Example 2

```math
A = \begin{bmatrix} 6.1 & 9.5 & 35.7 \end{bmatrix}
```

```math
L = 20
\quad
M = 10
```

```math
Y = \begin{bmatrix} \min(10, \max(6.1, 20)) & \min(10, \max(9.5, 20)) & \min(10, \max(35.7, 20)) \end{bmatrix}
```

```math
Y = \begin{bmatrix} 10 & 10 & 10 \end{bmatrix}
```

## Error conditions
No error condition

## Inputs

### $\text{X}$: `real tensor`
Tensor $X$ is the input tensor to be clipped within the specified bounds.

> As constraints refer to the ONNX interface definition, don't forget to rename the tensors (L=>"min", M=>"Max", etc.)

### Constraints

 - `[C1]` <a id="C1ra"></a> Shape consistency
   - Statement: Tensors $X$ and $Y$ must have the same shape.
 
### $\text{L}$: `real tensor`
Tensor $L$ is the minimum bound for clipping.

The shape of tensor $L$ must be empty (scalar).
> Remove this as it is a constraint. 

### Constraints
Tensor $L$ has no constraints.

> Add a constraint about the shape (same for "M"): the shape of tensor "min" must be empty. 

### $\text{M}$: `real tensor`
Tensor $M$ is the maximum bound for clipping.

The shape of tensor $M$ must be empty (scalar).

### Constraints
Tensor $M$ has no constraints.

## Outputs

### $\text{Y}$: `real tensor`
Tensor $Y$ is the element-wise result of clipping $X$ by the interval $[L, M]$.

### Constraints

 - `[C1]` Shape consistency
   - Statement: see constraint [<b><span style="font-family: 'Courier New', monospace">[C1]</span></b>](#C1ra) on tensor $X$.

## Attributes

Operator $\text{Clip}$ has no attribute.

## Formal specification
 
See the [Why3 specification]().
> Add a hyperlink to the formal spec.

## Numerical Accuracy

Operator $\text{Clip}$ does not introduce any numerical error. Hence, for all valid indexes, the output values are exactly equal to the corresponding input values.

> Replace by a link to file "clip_na.md" (located at the same level as the informal spec.). This file will contain part of the spec concerning numerical accuracy.

<a id="int"></a>
# **clip** (int, int, int)
where int is in {INT8, INT16, INT32, INT64, UINT8, UINT16, UINT32, UINT64}

> First letter of the operator must be capitalized.
> All types in lowercases
> Add a remark about the fact that the values used in all arguments are of the same type (even though it is implicit).  
 
## Signature
$Y = \text{Clip}(X,L,M)$

where:
- $X$: input tensor
- $L$: minimum tensor (empty shape tensor - scalar)
- $M$: maximum tensor (empty shape tensor - scalar)
## Restrictions
The following restrictions apply to the $\text{Clip}$ operator for the SONNX profile:

[General restrictions](../general_restrictions.md) are applicable.
## Informal specification

Operator $\text{Clip}$ limit the given input within an interval. For each element in the input tensor $X$: 
- If $L$ $\leq$ $M$:
  - if $X[i]$ < $L$ then $Y[i]$ = $L$.
  - If $X[i]$ > $M$ then $Y[i]$ = $M$.
  - Otherwise, $Y[i]$ = $X[i]$.
- If $L$ $\gt$ $M$:
  - $\forall i,\ Y[i] = M$

> Same as above: remove "forall i".

where $i$ is a [tensor index](../common/definitions.md#tensor_index).

The result is stored in output tensor $Y$.

Clip operation can be expressed as:

$$\forall i,\ Y[i] = \min(M, \max(X[i], L))$$

where $i$ is a [tensor index](../common/definitions.md#tensor_index).

### Example 1

```math
A = \begin{bmatrix} -6 & 9 & 35 \end{bmatrix}
```

```math
L = 0
\quad
M = 10
```

```math
Y = \begin{bmatrix} \min(10, \max(-6, 0)) & \min(10, \max(9, 0)) & \min(10, \max(35, 0)) \end{bmatrix}
```

```math
Y = \begin{bmatrix} 0 & 9 & 10 \end{bmatrix}
```

### Example 2

```math
A = \begin{bmatrix} 6 & 9 & 35 \end{bmatrix}
```

```math
L = 20
\quad
M = 10
```

```math
Y = \begin{bmatrix} \min(10, \max(6, 20)) & \min(10, \max(9, 20)) & \min(10, \max(35, 20)) \end{bmatrix}
```

```math
Y = \begin{bmatrix} 10 & 10 & 10 \end{bmatrix}
```

## Error conditions
No error condition

## Inputs

### $\text{X}$: INT8, INT16, INT32, INT64, UINT8, UINT16, UINT32, UINT64
Tensor $X$ is the input tensor to be clipped within the specified bounds.

> replace the list of types by "int", where "int" refers to the interface definition. That gives:
> **input: int**

### Constraints

 - `[C1]` <a id="C1ia"></a> Shape consistency
   - Statement: Tensors $X$ and $Y$ must have the same shape.
 - `[C2]` <a id="C2ia"></a> Type consistency
   - Statement: Tensors $X$, $L$, $M$ and $Y$ must have the same type.
 
### $\text{L}$: INT8, INT16, INT32, INT64, UINT8, UINT16, UINT32, UINT64
Tensor $L$ is the minimum bound for clipping.

The shape of tensor $L$ must be empty (scalar).

### Constraints
- `[C1]` Type consistency
  - Statement: see constraint [<b><span style="font-family: 'Courier New', monospace">[C2]</span></b>](#C2ia) on tensor $X$.

### $\text{M}$: INT8, INT16, INT32, INT64, UINT8, UINT16, UINT32, UINT64
Tensor $M$ is the maximum bound for clipping.

The shape of tensor $M$ must be empty (scalar).
### Constraints
- `[C1]` Type consistency
  - Statement: see constraint [<b><span style="font-family: 'Courier New', monospace">[C2]</span></b>](#C2ia) on tensor $X$.

## Outputs

### $\text{Y}$: INT8, INT16, INT32, INT64, UINT8, UINT16, UINT32, UINT64
Tensor $Y$ is the element-wise result of clipping $X$ by the interval $[L, M]$.

### Constraints

 - `[C1]` Shape consistency
   - Statement: see constraint [<b><span style="font-family: 'Courier New', monospace">[C1]</span></b>](#C1ra) on tensor $X$.
 - `[C2]` Type consistency
   - Statement: see constraint [<b><span style="font-family: 'Courier New', monospace">  [C2]</span></b>](#C2ia) on tensor $X$.

## Attributes

Operator $\text{Clip}$ has no attribute.

## Formal specification
 
See the Why3 specification.

## Numerical Accuracy

Operator $\text{Clip}$ does not introduce any numerical error. Hence, for all valid indexes, the output values are exactly equal to the corresponding input values.


<a id="float"></a>
# **Clip** (float, float, float)
where float is in {FP16, FP32, FP64, BFLOAT16}

> Replace FP16 by "float16", FP32 by float,...
> Remove BFLOAT16 (which is not IEEE754) 

## Signature
$Y = \text{Clip}(X,L,M)$
where:
- $X$: input tensor
- $L$: minimum tensor (empty shape tensor - scalar)
- $M$: maximum tensor (empty shape tensor - scalar)

## Restrictions
The following restrictions apply to the $\text{Clip}$ operator for the SONNX profile:

[General restrictions](../general_restrictions.md) are applicable.

## Informal specification

Operator $\text{Clip}$ limits the given input within an interval. For each element in the input tensor $X$ (discarding $nan$ values in $L$ or $M$, for more details see the definition below):
> Remove "For each...".

- If $L$ $\leq$ $M$:

  - if $X[i]$ < $L$ then $Y[i]$ = $L$.

  - If $X[i]$ > $M$ then $Y[i]$ = $M$.
  - Otherwise, $Y[i]$ = $X[i]$.
- If $L$ $\gt$ $M$:
  - $\forall i,\ Y[i] = M$

where $i$ is a [tensor index](../common/definitions.md#tensor_index).

The result is stored in output tensor $Y$.

Clip operation can be divided into two steps:

- If any of the boundaries is $nan$ it is readjusted to the respetive extreme value:

  - If $L$ is $nan$, it is set to the lowest representable value.

> "nan" => "NaN"
> [IMPORTANT] Considering your example (onnxruntime), L must be substituted by -inf

  - If $M$ is $nan$, it is set to the highest representable value.

> [IMPORTANT] Considering your example (onnxruntime), M must be substituted by +inf

- The clipping is then performed as:

> Move the previous items about NaNs in the spec "if L <= M ...", with a specific test.

$$\forall i,\ Y[i] = \min(M, \max(X[i], L))$$

where $i$ is a [tensor index](../common/definitions.md#tensor_index).


### Example 1

```math
A = \begin{bmatrix} -6.3 & 9.2 & 35.5 \end{bmatrix}
```

```math
L = 0.5
\quad
M = 10.1
```
```math
Y = \begin{bmatrix} \min(10.1, \max(-6.3, 0.5)) & \min(10.1, \max(9.2, 0.5)) & \min(10.1, \max(35.5, 0.5)) \end{bmatrix}
```

```math
Y = \begin{bmatrix} 0.5 & 9.2 & 10.1 \end{bmatrix}
```

### Example 2

```math
A = \begin{bmatrix} 6.5 & 9.2 & 35.1 \end{bmatrix}
```

```math
L = 20.2
\quad
M = 10.0
```

```math
Y = \begin{bmatrix} \min(10.0, \max(6.5, 20.2)) & \min(10.0, \max(9.2, 20.2)) & \min(10.0, \max(35.1, 20.2)) \end{bmatrix}
```

```math
Y = \begin{bmatrix} 10.0 & 10.0 & 10.0 \end{bmatrix}
```

### Example 3

```math
A = \begin{bmatrix} -\infty & 0.0 & \infty & NaN \end{bmatrix}
```
```math
L = -1.0
\quad
M = NaN
```
```math
M = h 
```
where `h` is the highest representable value.

```math
Y = \begin{bmatrix} \min(h, \max(-\infty, -1.0)) & \min(h, \max(0.0, -1.0)) & \min(h, \max(\infty, -1.0)) & \min(h, \max(NaN, -1.0)) \end{bmatrix}
```

```math
Y = \begin{bmatrix} -1.0 & 0.0 & \infty & NaN \end{bmatrix}
```

### Example 4

```math
A = \begin{bmatrix} -\infty & 0.0 & \infty & NaN \end{bmatrix}
```
```math
L = NaN
\quad
M = NaN
```
```math
L = l \quad M = h
```
where: 
  - `l` is the lowest representable value and 
  - `h` is the highest representable value.

```math
Y = \begin{bmatrix} \min(h, \max(-\infty, l)) & \min(h, \max(0.0, l)) & \min(h, \max(\infty, l)) & \min(h, \max(NaN, l)) \end{bmatrix}
```

```math
Y = \begin{bmatrix} -\infty & 0.0 & \infty & NaN \end{bmatrix}
```

## Error conditions
- Values of the output tensor may be IEEE 754 infinity or NaN

## Inputs

### $\text{X}$: FP16, FP32, FP64, BFLOAT16
Tensor $X$ is the input tensor to be clipped within the specified bounds.

### Constraints

 - `[C1]` <a id="C1ia"></a> Shape consistency
   - Statement: Tensors $X$ and $Y$ must have the same shape.
 - `[C2]` <a id="C2ia"></a> Type consistency
   - Statement: Tensors $X$, $L$, $M$ and $Y$ must have the same type.
 
### $\text{L}$: FP16, FP32, FP64, BFLOAT16
Tensor $L$ is the minimum bound for clipping.

The shape of tensor $L$ must be empty (scalar).

### Constraints
- `[C1]` Type consistency
  - Statement: see constraint [<b><span style="font-family: 'Courier New', monospace">[C2]</span></b>](#C2ia) on tensor $X$.

### $\text{M}$: FP16, FP32, FP64, BFLOAT16
Tensor $M$ is the maximum bound for clipping.

The shape of tensor $M$ must be empty (scalar).

### Constraints
- `[C1]` Type consistency
  - Statement: see constraint [<b><span style="font-family: 'Courier New', monospace">[C2]</span></b>](#C2ia) on tensor $X$.
## Outputs

### $\text{Y}$: FP16, FP32, FP64, BFLOAT16
Tensor $Y$ is the element-wise result of clipping $X$ by the interval $[L, M]$.
### Constraints

 - `[C1]` Shape consistency
   - Statement: see constraint [<b><span style="font-family: 'Courier New', monospace">[C1]</span></b>](#C1ra) on tensor $X$.
 - `[C2]` Type consistency
   - Statement: see constraint [<b><span style="font-family: 'Courier New', monospace">  [C2]</span></b>](#C2ia) on tensor $X$.

## Attributes

Operator $\text{Clip}$ has no attribute.

## Formal specification
 
See the Why3 specification.

## Numerical Accuracy
Operator $\text{Clip}$ does not introduce any numerical error. Hence, for all valid indexes, the output values are exactly equal to the corresponding input values.
