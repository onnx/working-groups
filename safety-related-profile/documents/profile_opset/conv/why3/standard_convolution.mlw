(* standard_convolution.mlw *)
module Conv2D_Int_Standard

  use int.Int
  use int.ComputerDivision
  use option.Option
  use list.List
  use sequence.Seq
  use tensor.Tensor
  use tensor.Shape
  use tensor.Index
  use tensor4d.Ops4D

(* ===== SECTION 1: Compute output's shape ===== *)

(* Goal: Calculates the output height (H_out) of the convolution operation.
   * Inputs:
   * h_in: int - Height of the input tensor X.
   * kh: int - Height of the kernel W.
   * pad_hb: int - Padding applied to the beginning (top) of the height dimension.
   * pad_he: int - Padding applied to the end (bottom) of the height dimension.
   * dil_h: int - Dilation factor for the height dimension.
   * str_h: int - Stride for the height dimension.
   * Outputs: int - The calculated output height. *)

  let function calculate_H_out (h_in kh: int) (pad_hb pad_he: int) (dil_h str_h: int) : int
    requires { str_h > 0 } requires { dil_h > 0 } requires { kh > 0 } requires { h_in > 0 }
    = ComputerDivision.div (h_in + pad_hb + pad_he - (dil_h * (kh - 1) + 1)) str_h + 1

(* Goal: Calculates the output width (W_out) of the convolution operation.
  Inputs:
   * w_in: int - Width of the input tensor X.
   * kw: int - Width of the kernel W.
   * pad_wb: int - Padding applied to the beginning (left) of the width dimension.
   * pad_we: int - Padding applied to the end (right) of the width dimension.
   * dil_w: int - Dilation factor for the width dimension.
   * str_w: int - Stride for the width dimension.
  Outputs: int - The calculated output width. *)

  let function calculate_W_out (w_in kw: int) (pad_wb pad_we: int) (dil_w str_w: int) : int
    requires { str_w > 0 } requires { dil_w > 0 } requires { kw > 0 }
    = ComputerDivision.div (w_in + pad_wb + pad_we - (dil_w * (kw - 1) + 1)) str_w + 1

 
   (* ===== SECTION 2: Summation helpers ===== *)
  
(* Goal: Retrieves a value from the input tensor, accounting for padding. If the effective coordinates
   fall within a padded region, it returns 0. Otherwise, it returns the value from the original tensor.
  Inputs:
   * x: tensor int - The input tensor X.
   * n_idx: int - The batch index.
   * c_in_idx: int - The input channel index.
   * h_eff: int - The effective height coordinate in the conceptually padded input space.
   * w_eff: int - The effective width coordinate in the conceptually padded input space.
   * current_pad_h_begin: int - The padding applied to the top of the height dimension.
   * current_pad_w_begin: int - The padding applied to the left of the width dimension.
  Outputs: int - The value from the input tensor at the calculated original coordinates, or 0 if padded. *)

  let function get_padded_input_value (x: tensor int)
                                       (n_idx c_in_idx h_eff w_eff: int)
                                       (current_pad_h_begin current_pad_w_begin: int)
                                       : int
    requires { dim x = 4 }
    requires { (0 <= n_idx < Ops4D.n_dim x) /\ (0 <= c_in_idx < Ops4D.c_dim x) -> true }
  =
    let x_h_dim = Ops4D.h_dim x in
    let x_w_dim = Ops4D.w_dim x in
    let h_orig = h_eff - current_pad_h_begin in
    let w_orig = w_eff - current_pad_w_begin in
    if 0 <= n_idx < Ops4D.n_dim x &&
       0 <= c_in_idx < Ops4D.c_dim x &&
       0 <= h_orig < x_h_dim &&
       0 <= w_orig < x_w_dim then
      Ops4D.get4d x n_idx c_in_idx h_orig w_orig
    else
      0

(* Goal: Recursively sums the products of input tensor values and kernel weights across the kernel's width dimension.
  Inputs:
   * x_tensor: tensor int - The input tensor X.
   * w_tensor: tensor int - The kernel tensor W.
   * pads_attr: seq int - Sequence of padding attributes [H_begin, W_begin, H_end, W_end].
   * dilations_attr: seq int - Sequence of dilation attributes [D_h, D_w].
   * strides_attr: seq int - Sequence of stride attributes [S_h, S_w].
   * n: int - Current batch index.
   * c_out: int - Current output channel index.
   * c_in: int - Current input channel index.
   * h_out: int - Current output height index.
   * w_out: int - Current output width index.
   * kh: int - Current kernel height index.
   * kw_iter: int - Current kernel width index (iterator for recursion).
  Outputs: int - The sum of (input_value * kernel_weight) for the current kernel height and input/output channels. *)

  let rec function sum_over_kw (x_tensor w_tensor: tensor int)
                               (pads_attr dilations_attr strides_attr: seq int)
                               (n c_out c_in h_out w_out kh kw_iter: int) : int
    requires { dim x_tensor = 4 /\ dim w_tensor = 4 }
    requires { Seq.length strides_attr = 2 }
    requires { Seq.length dilations_attr = 2 }
    requires { Seq.length pads_attr = 4 }
    requires { Ops4D.w_dim w_tensor > 0 }
    requires { Ops4D.h_dim w_tensor > 0 }
    requires { 0 <= n < Ops4D.n_dim x_tensor }
    requires { 0 <= c_out < Ops4D.n_dim w_tensor }
    requires { 0 <= c_in  < Ops4D.c_dim x_tensor }
    requires { 0 <= c_in  < Ops4D.c_dim w_tensor }
    requires { 0 <= kh < Ops4D.h_dim w_tensor }
    requires { 0 <= kw_iter <= Ops4D.w_dim w_tensor }
    variant  { Ops4D.w_dim w_tensor - kw_iter }
  =
    if kw_iter >= Ops4D.w_dim w_tensor then 0
    else
      let h_eff = h_out * (Ops4D.stride_h strides_attr) + kh * (Ops4D.dilation_h dilations_attr) in
      let w_eff = w_out * (Ops4D.stride_w strides_attr) + kw_iter * (Ops4D.dilation_w dilations_attr) in
      let x_val = get_padded_input_value x_tensor n c_in h_eff w_eff
                                         (Ops4D.pad_h_begin pads_attr) (Ops4D.pad_w_begin pads_attr) in
      let w_val = Ops4D.get4d w_tensor c_out c_in kh kw_iter in
      x_val * w_val + sum_over_kw x_tensor w_tensor pads_attr dilations_attr strides_attr
                                  n c_out c_in h_out w_out kh (kw_iter + 1)

(* Goal: Recursively sums the results from 'sum_over_kw' across the kernel's height dimension.
  Inputs:
   * x_tensor: tensor int - The input tensor X.
   * w_tensor: tensor int - The kernel tensor W.
   * pads_attr: seq int - Sequence of padding attributes [H_begin, W_begin, H_end, W_end].
   * dilations_attr: seq int - Sequence of dilation attributes [D_h, D_w].
   * strides_attr: seq int - Sequence of stride attributes [S_h, S_w].
   * n_for_x: int - Current batch index.
   * c_out_for_w: int - Current output channel index.
   * c_in_for_both: int - Current input channel index.
   * h_out_val: int - Current output height index.
   * w_out_val: int - Current output width index.
   * kh_iter_for_w: int - Current kernel height index (iterator for recursion).
  Outputs: int - The sum of products for the current input/output channels, across all kernel heights and widths. *)

  let rec function sum_over_kh (x_tensor w_tensor: tensor int)
                               (pads_attr dilations_attr strides_attr: seq int)
                               (n_for_x c_out_for_w c_in_for_both h_out_val w_out_val kh_iter_for_w: int) : int
    requires { dim x_tensor = 4 /\ dim w_tensor = 4 }
    requires { Seq.length strides_attr = 2 /\ Seq.length dilations_attr = 2 /\ Seq.length pads_attr = 4 }
    requires { Ops4D.h_dim w_tensor > 0 /\ Ops4D.w_dim w_tensor > 0 }
    requires { 0 <= n_for_x < Ops4D.n_dim x_tensor }
    requires { 0 <= c_out_for_w < Ops4D.n_dim w_tensor }
    requires { 0 <= c_in_for_both < Ops4D.c_dim x_tensor }
    requires { 0 <= c_in_for_both < Ops4D.c_dim w_tensor }
    requires { 0 <= kh_iter_for_w <= Ops4D.h_dim w_tensor }
    variant  { Ops4D.h_dim w_tensor - kh_iter_for_w }
  =
    if kh_iter_for_w >= Ops4D.h_dim w_tensor then 0
    else
      sum_over_kw x_tensor w_tensor pads_attr dilations_attr strides_attr
                  n_for_x c_out_for_w c_in_for_both h_out_val w_out_val kh_iter_for_w 0  (* Pass 0 for kw_iter *)
      + sum_over_kh x_tensor w_tensor pads_attr dilations_attr strides_attr
                    n_for_x c_out_for_w c_in_for_both h_out_val w_out_val (kh_iter_for_w + 1)

(* Goal: Recursively sums the results from 'sum_over_kh' across all input channels. This function
   computes the complete weighted sum for a single output pixel before bias addition.
   Inputs:
   * x_tensor: tensor int - The input tensor X.
   * w_tensor: tensor int - The kernel tensor W.
   * pads_attr: seq int - Sequence of padding attributes [H_begin, W_begin, H_end, W_end].
   * dilations_attr: seq int - Sequence of dilation attributes [D_h, D_w].
   * strides_attr: seq int - Sequence of stride attributes [S_h, S_w].
   * n_for_x: int - Current batch index.
   * c_out_for_w: int - Current output channel index.
   * h_out_val: int - Current output height index.
   * w_out_val: int - Current output width index.
   * c_in_iter_for_both: int - Current input channel index (iterator for recursion).
  Outputs: int - The total weighted sum for the specified output pixel (before bias). *)

  let rec function sum_over_c_in (x_tensor w_tensor: tensor int)
                               (pads_attr dilations_attr strides_attr: seq int)
                               (n_for_x c_out_for_w h_out_val w_out_val c_in_iter_for_both: int) : int
    requires { dim x_tensor = 4 /\ dim w_tensor = 4 }
    requires { Seq.length strides_attr = 2 }
    requires { Seq.length dilations_attr = 2 }
    requires { Seq.length pads_attr = 4 }
    requires { Ops4D.c_dim x_tensor = Ops4D.c_dim w_tensor } 
    requires { Ops4D.h_dim w_tensor > 0 /\ Ops4D.w_dim w_tensor > 0 } 
    requires { Ops4D.c_dim x_tensor > 0 } 
    requires { 0 <= n_for_x < Ops4D.n_dim x_tensor }
    requires { 0 <= c_out_for_w < Ops4D.n_dim w_tensor }
    requires { 0 <= c_in_iter_for_both <= Ops4D.c_dim x_tensor } 
    variant  { Ops4D.c_dim x_tensor - c_in_iter_for_both }
  =
    if c_in_iter_for_both >= Ops4D.c_dim x_tensor then 0
    else
      
      sum_over_kh x_tensor w_tensor pads_attr dilations_attr strides_attr
                  n_for_x c_out_for_w c_in_iter_for_both h_out_val w_out_val 0 (* Pass 0 for kh_iter *)
      + sum_over_c_in x_tensor w_tensor pads_attr dilations_attr strides_attr
                      n_for_x c_out_for_w h_out_val w_out_val (c_in_iter_for_both + 1)


(* ===== SECTION 3: Output Shape Calculation ===== *)

(* Goal: Calculates the shape of the output tensor Y for a convolution operation.
   * Inputs:
   * x: tensor int - The input tensor X.
   * w: tensor int - The kernel tensor W.
   * strides: seq int - Sequence of stride attributes [S_h, S_w].
   * pads: seq int - Sequence of padding attributes [H_begin, W_begin, H_end, W_end].
   * dilations: seq int - Sequence of dilation attributes [D_h, D_w].
   * Outputs: Shape.shape - The calculated 4D shape (N, C_out, H_out, W_out) of the output tensor. *)

  let function conv2d_output_shape (x w: tensor int)
                                   (strides pads dilations: seq int) : Shape.shape
    requires { dim x = 4 /\ dim w = 4 }
    requires { Ops4D.h_dim w > 0 /\ Ops4D.w_dim w > 0 }

(* Length preconditions for attribute sequences *)
    requires { Seq.length strides = 2 }
    requires { Seq.length pads = 4 }
    requires { Seq.length dilations = 2 }

    requires { Ops4D.stride_h strides > 0 /\ Ops4D.stride_w strides > 0 }
    requires { Ops4D.pad_h_begin pads >= 0 /\ Ops4D.pad_w_begin pads >= 0 /\
               Ops4D.pad_h_end pads >= 0   /\ Ops4D.pad_w_end pads >= 0 }
    requires { Ops4D.dilation_h dilations > 0 /\ Ops4D.dilation_w dilations > 0 }
    requires {
              
               let h_out_calc = calculate_H_out (Ops4D.h_dim x) (Ops4D.h_dim w)
                                                (Ops4D.pad_h_begin pads) (Ops4D.pad_h_end pads)
                                                (Ops4D.dilation_h dilations) (Ops4D.stride_h strides) in
               let w_out_calc = calculate_W_out (Ops4D.w_dim x) (Ops4D.w_dim w)
                                                (Ops4D.pad_w_begin pads) (Ops4D.pad_w_end pads)
                                                (Ops4D.dilation_w dilations) (Ops4D.stride_w strides) in
               h_out_calc > 0 /\ w_out_calc > 0
             }
    requires { Ops4D.n_dim x > 0 /\ Ops4D.n_dim w > 0 }
    ensures { length result.dims = 4 }
    ensures { Shape.positive result.dims }
  =
    let out_N = Ops4D.n_dim x in
    let out_C = Ops4D.n_dim w in
    
    let out_H = calculate_H_out (Ops4D.h_dim x) (Ops4D.h_dim w)
                                     (Ops4D.pad_h_begin pads) (Ops4D.pad_h_end pads)
                                     (Ops4D.dilation_h dilations) (Ops4D.stride_h strides) in
    let out_W = calculate_W_out (Ops4D.w_dim x) (Ops4D.w_dim w)
                                     (Ops4D.pad_w_begin pads) (Ops4D.pad_w_end pads)
                                     (Ops4D.dilation_w dilations) (Ops4D.stride_w strides) in
    assert { out_N > 0 /\ out_C > 0 /\ out_H > 0 /\ out_W > 0 };
    let s_dims = Cons out_N (Cons out_C (Cons out_H (Cons out_W Nil))) in
    { Shape.dims = s_dims }

  (* ===== SECTION 4: Output value Calculation ===== *)

(* Goal: Generates a function that computes the value of any given output pixel. 
  Inputs:
   * x: tensor int - The input tensor X.
   * w: tensor int - The kernel (weights) tensor W.
   * b: option (tensor int) - An optional 1D bias tensor.
   * strides: seq int - Sequence of stride attributes [S_h, S_w].
   * pads: seq int - Sequence of padding attributes [H_begin, W_begin, H_end, W_end].
   * dilations: seq int - Sequence of dilation attributes [D_h, D_w].
   * out_shape_param: Shape.shape - The pre-calculated shape of the output tensor.
  Outputs: (Index.index -> int) - A function that takes a 4D index of the output tensor (n, c_out, h_out, w_out)
  and returns its computed integer value. *)

  let function conv2d_output_value (x w: tensor int) (b: option (tensor int))
                                  (strides pads dilations: seq int)
                                  (out_shape_param: Shape.shape)
                                  : (Index.index -> int)
                          
  requires { dim x = 4 /\ dim w = 4 }
  requires { Ops4D.c_dim x  = Ops4D.c_dim w  }
  requires { Ops4D.c_dim x > 0} 
  requires { Ops4D.h_dim w > 0 /\ Ops4D.w_dim w > 0}
  requires { Ops4D.n_dim w > 0} 
  requires { Ops4D.n_dim x > 0}

    requires { length strides = 2 }
    requires { length pads = 4 }
    requires { length dilations = 2 }
    requires { Shape.positive out_shape_param.dims }
    requires { match b with
               | None -> true
               | Some b_tensor ->
                   dim b_tensor = 1
               end
             }
  
       =
    fun (output_idx: Index.index) ->
    requires { Index.valid output_idx out_shape_param }
      let n_loop     = output_idx[0] in
      let c_out_loop = output_idx[1] in
      let h_out_loop = output_idx[2] in
      let w_out_loop = output_idx[3] in
      
      let summed_val = sum_over_c_in x w pads dilations strides 
                                     n_loop c_out_loop h_out_loop w_out_loop 0 in
      let bias_val =
        match b with 
        | None -> 0
        | Some b_tensor -> (b_tensor.value (Cons c_out_loop Nil))
        end
      in
      summed_val + bias_val

(* Goal: Implements the full 2D convolution operator. It computes the output tensor Y
  based on the input tensor X, kernel W, optional bias B, and convolution attributes.
  Inputs:
   * x: tensor int - The input tensor X (N, C_in, H_in, W_in).
   * w: tensor int - The kernel tensor W (C_out, C_in, K_h, K_w).
   * b: option (tensor int) - An optional 1D bias tensor (C_out).
   * strides: seq int - Stride attributes [S_h, S_w].
   * pads: seq int - Padding attributes [H_begin, W_begin, H_end, W_end].
   * dilations: seq int - Dilation attributes [D_h, D_w].
   * group_val: int - Number of groups (expected to be 1 for standard conv2d).
   * auto_pad_is_not_set: bool - Flag indicating that auto_pad mode is 'NOTSET'.
  Outputs: tensor int - The resulting output tensor Y (N, C_out, H_out, W_out). *)
  
  let function conv2d_int (x: tensor int) (w: tensor int) (b: option (tensor int))
                           (strides pads dilations: seq int)
                           (group_val: int) 
                           (auto_pad_is_not_set: bool)
                           : tensor int

    (* --- Core Tensor Dimension Requirements --- *)
    requires { dim x = 4 /\ dim w = 4 }
    requires { Ops4D.c_dim x = Ops4D.c_dim w } 
    requires { Ops4D.c_dim x > 0 } 
    requires { Ops4D.h_dim w > 0 /\ Ops4D.w_dim w > 0 } 
    requires { Ops4D.n_dim w > 0 } 
    requires { Ops4D.n_dim x > 0 } 

    (* --- Attribute Sequence Length Requirements --- *)
    requires { Seq.length strides = 2 }
    requires { Seq.length pads = 4 }
    requires { Seq.length dilations = 2 }

    (* --- Attribute Value Domain Requirements --- *)
    requires { Ops4D.stride_h strides > 0 /\ Ops4D.stride_w strides > 0 }
    requires { Ops4D.pad_h_begin pads >= 0 /\ Ops4D.pad_w_begin pads >= 0 /\
               Ops4D.pad_h_end pads >= 0 /\ Ops4D.pad_w_end pads >= 0 }
    requires { Ops4D.dilation_h dilations > 0 /\ Ops4D.dilation_w dilations > 0 }

    (* --- ONNX Profile Restrictions --- *)
    requires { group_val = 1 } 
    requires { auto_pad_is_not_set } 

    (* --- Conditional Bias Tensor Constraints --- *)
    requires { match b with
               | None -> true 
               | Some b_tensor ->
                   dim b_tensor = 1
               end
             }

    
    requires {
               let h_out_calc = calculate_H_out (Ops4D.h_dim x) (Ops4D.h_dim w)
                                                (Ops4D.pad_h_begin pads) (Ops4D.pad_h_end pads)
                                                (Ops4D.dilation_h dilations) (Ops4D.stride_h strides) in
               let w_out_calc = calculate_W_out (Ops4D.w_dim x) (Ops4D.w_dim w)
                                                (Ops4D.pad_w_begin pads) (Ops4D.pad_w_end pads)
                                                (Ops4D.dilation_w dilations) (Ops4D.stride_w strides) in
               h_out_calc > 0 /\ w_out_calc > 0
             }
  =
    let res_shape = conv2d_output_shape x w strides pads dilations in
    let res_value_func = conv2d_output_value x w b strides pads dilations res_shape in
    { shape = res_shape; value = res_value_func }

end