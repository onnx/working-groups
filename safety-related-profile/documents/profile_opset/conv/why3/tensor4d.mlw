module Ops4D
  use int.Int
  use ref.Ref
  use list.List
  use list.Nth
  use sequence.Seq
  use tensor.Tensor
  use tensor.Shape
  use tensor.Index

  (** Goal: Lemma to help prove that a list of four positive integers forms a valid positive shape. **)
  (* Inputs:
      d1, d2, d3, d4: int - Four integers representing dimensions.
    Outputs:
      True if all d1, d2, d3, d4 are positive, indicating the list forms a positive shape.
  *)
  lemma positive_4_list_lemma:
    forall d1 d2 d3 d4: int.
      d1 > 0 -> d2 > 0 -> d3 > 0 -> d4 > 0 ->
      Shape.positive (Cons d1 (Cons d2 (Cons d3 (Cons d4 Nil))))

(* --- 4D Tensor Dimension Accessors --- *)

(** Goal: Accesses the batch (N) dimension of a 4D tensor. **)
 (* Inputs: t: tensor 'a - A 4D tensor.
    Outputs: int - The value of the N dimension. *)

  let function n_dim (t: tensor 'a) : int
    requires { dim t = 4 } = (t.shape.dims)[0]

  (** Goal: Accesses the channel (C) dimension of a 4D tensor. **)
  (*  Inputs: t: tensor 'a - A 4D tensor.
      Outputs: int - The value of the C dimension. *)

  let function c_dim (t: tensor 'a) : int
    requires { dim t = 4 } = (t.shape.dims)[1]

  (** Goal: Accesses the height (H) dimension of a 4D tensor. **)
  (*  Inputs: t: tensor 'a - A 4D tensor.
      Outputs: int - The value of the H dimension. *)

  let function h_dim (t: tensor 'a) : int
    requires { dim t = 4 } = (t.shape.dims)[2]

  (** Goal: Accesses the width (W) dimension of a 4D tensor. **)
  (*  Inputs: t: tensor 'a - A 4D tensor.
      Outputs: int - The value of the W dimension. *)

  let function w_dim (t: tensor 'a) : int
    requires { dim t = 4 } = (t.shape.dims)[3]

  (* --- Attribute Sequence Accessors --- *)
  
(** Goal: Accesses the height (H) component of a stride sequence. **)
(*  Inputs: strides_seq: seq int - A sequence of integers representing strides, typically [H, W].
    Outputs: int - The stride value for the height dimension. *)

  let function stride_h (strides_seq: seq int) : int
    requires { Seq.length strides_seq = 2 } 
  = (strides_seq)[0] 

  (** Goal: Accesses the width (W) component of a stride sequence. **)
  (*  Inputs: strides_seq: seq int - A sequence of integers representing strides, typically [H, W].
      Outputs: int - The stride value for the width dimension. *)

  let function stride_w (strides_seq: seq int) : int
    requires { Seq.length strides_seq = 2 }
  = (strides_seq)[1] 

(** Goal: Accesses the beginning height (H_begin) component of a pad sequence. **)
(*   Inputs: pads_seq: seq int - A sequence of integers representing pads, typically [H_begin, W_begin, H_end, W_end].
     Outputs: int - The padding value for the beginning of the height dimension. *)
  let function pad_h_begin (pads_seq: seq int) : int
    requires { Seq.length pads_seq = 4 } = (pads_seq)[0]
(** Goal: Accesses the beginning width (W_begin) component of a pad sequence. **)
(*  Inputs: pads_seq: seq int - A sequence of integers representing pads, typically [H_begin, W_begin, H_end, W_end].
    Outputs: int - The padding value for the beginning of the width dimension. *)
  let function pad_w_begin (pads_seq: seq int) : int
    requires { Seq.length pads_seq = 4 } = (pads_seq)[1]

(** Goal: Accesses the ending height (H_end) component of a pad sequence. **)
(*  Inputs: pads_seq: seq int - A sequence of integers representing pads, typically [H_begin, W_begin, H_end, W_end].
    Outputs: int - The padding value for the end of the height dimension. *)
  let function pad_h_end (pads_seq: seq int) : int
    requires { Seq.length pads_seq = 4 } = (pads_seq)[2]

(** Goal: Accesses the ending width (W_end) component of a pad sequence. **)
(*  Inputs: pads_seq: seq int - A sequence of integers representing pads, typically [H_begin, W_begin, H_end, W_end].
    Outputs: int - The padding value for the end of the width dimension. *)
  let function pad_w_end (pads_seq: seq int) : int
    requires { Seq.length pads_seq = 4 } = (pads_seq)[3]

(** Goal: Accesses the height (H) component of a dilation sequence. **)
(*  Inputs: dilations_seq: seq int - A sequence of integers representing dilations, typically [H, W].
    Outputs: int - The dilation value for the height dimension. *)
  let function dilation_h (dilations_seq: seq int) : int
    requires { Seq.length dilations_seq = 2 } = (dilations_seq)[0]

(** Goal: Accesses the width (W) component of a dilation sequence. **)
(*  Inputs: dilations_seq: seq int - A sequence of integers representing dilations, typically [H, W].
    Outputs: int - The dilation value for the width dimension.*)
  let function dilation_w (dilations_seq: seq int) : int
    requires { Seq.length dilations_seq = 2 } = (dilations_seq)[1]


  (* --- Getter for 4D Tensors --- *)

  (** Goal: Retrieves the value at a specific 4D index (n, c, h, w) from a 4D tensor. **)
  (*  Inputs:
      t: tensor 'a - The 4D tensor.
      n: int - The index for the batch dimension.
      c: int - The index for the channel dimension.
      h: int - The index for the height dimension.
      w: int - The index for the width dimension.
    Outputs:
      'a - The value stored at the given 4D index.
  *)
  let function get4d (t: tensor 'a) (n c h w: int) : 'a
    requires { dim t = 4 }
    requires { 0 <= n < n_dim t } 
    requires { 0 <= c < c_dim t }
    requires { 0 <= h < h_dim t }
    requires { 0 <= w < w_dim t }
  =
    let idx4d : index = Cons n (Cons c (Cons h (Cons w Nil))) in
    t.value idx4d

end
