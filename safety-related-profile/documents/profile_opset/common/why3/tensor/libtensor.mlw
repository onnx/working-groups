module CTensor
  use std.Int
  use std.List
  use std.Clib
  use std.Cfloat
  use mach.int.Int32
  use tensor.Range
  use tensor.Tensor
  use tensor.OPWhere
  use layout.CFlat
  use libvector.CIndex

  type farray = ptr float

  type ctensor = {
    t_rank : int32 ;
    t_dims : iarray ;
    t_data : farray ;
  }

  function tensor_dim (t : ctensor) : list int = ivector t.t_dims t.t_rank
  function tensor_size (t : ctensor) : int = vdim t.t_dims t.t_rank
  predicate valid_index (k : list int) (t : ctensor) = valid k (tensor_dim t)
  predicate empty_tensor (t : ctensor) = t.t_rank = 0

  predicate valid_tensor (t : ctensor) =
    dimension t.t_dims t.t_rank /\
    valid_range t.t_data 0 (tensor_size t) /\
    writable t.t_data

  function tensor_offset (k : list int) (t : ctensor) : int = offset k (tensor_dim t)

  function tensor_value_at (k : list int) (t : ctensor) : real =
    if valid_index k t then
      value_at t.t_data (tensor_offset k t)
    else 0.0

  function tensor_value (t : ctensor) : list int -> real =
    fun k -> tensor_value_at k t

  function tensor_valueb (t : ctensor) : list int -> bool =
    fun k -> Real.(tensor_value_at k t > 0.0)

  let ghost function tensor (t : ctensor) : tensor real
    (*proof*)
    requires { valid_tensor t }
    ensures { result.dims = tensor_dim t }
    ensures { result.data = tensor_value t }
    ensures { result.background = 0.0 }
    (*qed*)
    = {
      dims = pure { tensor_dim t } ;
      data = pure { tensor_value t } ;
      background = 0.0 ;
    }

  let ghost function tensorb (t : ctensor) : tensor bool
    (*proof*)
    requires { valid_tensor t }
    ensures { result.dims = tensor_dim t }
    ensures { result.data = tensor_valueb t }
    ensures { result.background = false }
    (*qed*)
    = {
      dims = pure { tensor_dim t } ;
      data = pure { tensor_valueb t } ;
      background = false ;
    }

  let ctensor_create (ds : iarray) (n : int32) : ctensor =
    (*proof*)
    requires { dimension ds n }
    ensures { empty_tensor result \/ valid_tensor result }
    ensures { empty_tensor result \/ result.t_rank = n }
    ensures { empty_tensor result \/ result.t_dims = ds }
    (*qed*)
    let m = cdim_size ds n in
    let vs = malloc (to_uint32 m) in
    {
      t_rank = if is_null vs then 0 else n ;
      t_dims = ds ;
      t_data = vs ;
    }

  let ctensor_clear (r : ctensor) =
    requires { valid_tensor r }
    ensures { tensor r = Tensor.zero 0.0 (tensor_dim r) }
    let m = cdim_size r.t_dims r.t_rank in
    for i = 0 to m-1 do
      (*proof*)
      invariant { forall k. 0 <= k < i -> value_at r.t_data k = 0.0 }
      (*qed*)
      r.t_data[i] <- f32 0.0
    done
    (*proof*)
    ; assert { tensor r == Tensor.zero 0.0 (tensor_dim r) }
    (*qed*)

  let ctensor_reset (r : ctensor) (v : float) =
    requires { valid_tensor r }
    ensures { tensor r = Tensor.const (to_real v) 0.0 (tensor_dim r) }
    let m = cdim_size r.t_dims r.t_rank in
    for i = 0 to m-1 do
      (*proof*)
      invariant { forall k. 0 <= k < i -> value_at r.t_data k = v }
      (*qed*)
      r.t_data[i] <- v
    done
    (*proof*)
    ; assert { tensor r == Tensor.const (to_real v) 0.0 (tensor_dim r) }
    (*qed*)

  let ctensor_where (cond a b r : ctensor) =
    (*proof*)
    requires { valid_tensor cond }
    requires { valid_tensor a }
    requires { valid_tensor b }
    requires { valid_tensor r }
    requires { tensor a ~= tensor b ~= tensor r }
    (*qed*)
    requires { tensorb cond ~ tensor a ~ tensor b }
    ensures { tensor r = opwhere (tensorb cond) (tensor a) (tensor b) }
    let m = cdim_size r.t_dims r.t_rank in
    for i = 0 to m-1 do
      (*proof*)
      invariant {
        forall k. 0 <= k < i ->
          value_at r.t_data k =
            if Real.(0.0 < value_at cond.t_data k)
            then a.t_data[k] else b.t_data[k]
      }
      (*qed*)
      r.t_data[i] <-
        if (f32 0.0) .< cond.t_data[i] then a.t_data[i] else b.t_data[i]
    done
    (*proof*)
    ; assert { tensor r == opwhere (tensorb cond) (tensor a) (tensor b) }
    (*qed*)

end
